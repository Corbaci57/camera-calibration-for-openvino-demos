import sys
import math
import argparse

import cv2
import numpy as np

import json

def draw_axis(img, corners, imgpts):
    corner = tuple(corners[0].ravel())
    X = tuple(imgpts[0].ravel())
    Y = tuple(imgpts[1].ravel())
    Z = tuple(imgpts[2].ravel())
    img = cv2.line(img, corner, X, (255,0,0), 5)
    img = cv2.line(img, corner, Y, (0,255,0), 5)
    img = cv2.line(img, corner, Z, (0,0,255), 5)
    cv2.putText(img,  'X', X, cv2.FONT_HERSHEY_PLAIN, 2, (255,0,0), 2)
    cv2.putText(img,  'Y', Y, cv2.FONT_HERSHEY_PLAIN, 2, (0,255,0), 2)
    cv2.putText(img, '-Z', Z, cv2.FONT_HERSHEY_PLAIN, 2, (0,0,255), 2)
    return img

def draw_sticker(img, corners, imgpts, sticker):
    corner = tuple(corners[0].ravel())
    p0 = tuple(imgpts[0].ravel())
    p1 = tuple(imgpts[1].ravel())
    p2 = tuple(imgpts[2].ravel())
    p3 = tuple(imgpts[3].ravel())
    sticker_h, sticker_w = sticker.shape[0:1+1]
    img_h, img_w = img.shape[0:1+1]
    src = np.array([[0,0], [sticker_w, 0], [sticker_w, sticker_h], [0, sticker_h]], dtype=np.float32)
    dst = np.array([[p0[0], p0[1]], [p1[0], p1[1]], [p2[0], p2[1]], [p3[0], p3[1]]], dtype=np.float32)
    mat = cv2.getPerspectiveTransform(src, dst)
    img_a = cv2.warpPerspective(sticker, mat, (img_w, img_h))
    cv2.fillConvexPoly(img, dst.astype(np.int32), (0,0,0))
    img |= img_a
    return img

def main(args):

    # Load camera calibration data generated by 'camera_calibration.py'
    with np.load(args.calib+'.npz') as X:
        mtx, dist, _, _ = [X[i] for i in ('mtx','dist','rvecs','tvecs')]

    sticker = cv2.imread(args.input)
    if sticker is None:
        print('Failed to load a sticker image \'{}\''.format(args.input))
        sys.exit(1)

    criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
    gx, gy = eval(args.grid_size)
    objp = np.zeros((gx*gy,3), np.float32)
    objp[:,:2] = np.mgrid[0:gx,0:gy].T.reshape(-1,2)

    axis_coord = np.float32([[3,0,0], [0,3,0], [0,0,-3]]).reshape(-1,3)
    sticker_coord = np.float32([[0,0,0], [gx-1,0,0], [gx-1,gy-1,0], [0,gy-1,0]]).reshape(-1,3)

    cap = cv2.VideoCapture(args.cam)
    if cap.isOpened() == False:
        print('Failed to open WebCam({})'.format(args.cam))
        sys.exit(1)

    rad = 0

    while True:
        ret, img = cap.read()
        if ret == False:
            break
        gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
        ret, corners = cv2.findChessboardCorners(gray, (gx,gy),None)

        if ret == True:
            corners2 = cv2.cornerSubPix(gray,corners,(11,11),(-1,-1),criteria)

            # Find the rotation and translation vectors.
            _, rvecs, tvecs, inliers = cv2.solvePnPRansac(objp, corners2, mtx, dist)

            # project 3D points to image plane
            imgpts, jac = cv2.projectPoints(sticker_coord, rvecs, tvecs, mtx, dist)
            img = draw_sticker(img, corners2, imgpts, sticker)
            imgpts, jac = cv2.projectPoints(axis_coord, rvecs, tvecs, mtx, dist)
            img = draw_axis(img, corners2, imgpts)

        cv2.imshow('img',img)
        key = cv2.waitKey(1) & 0xff
        if key == 27:
            break
        if key == ord(' ') and ret == True:     # Exit only when chess board corners are detected
            rot_mat, _ = cv2.Rodrigues(rvecs)           # convert a rotation vector into rotation matrix
            calib={'R': rot_mat.tolist(), 't':tvecs[0].tolist()}
            with open(args.output, 'w') as f:
                json.dump(calib, f, indent=4)
            print(json.dumps(calib, indent=4))
            print('extrinsics.json is generated (\'{}\')'.format(args.output))
            break

    cv2.destroyAllWindows()

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-i', '--input', type=str, required=False, default='image.jpg', help='Image file to be displayed on the chess board. default=\'image.jpg\'')
    parser.add_argument('-calib', type=str, required=False, default='calib', help='Camera calibration data base file name (without \'.npz\'). default=\'calib\'')
    parser.add_argument('-gs', '--grid_size', type=str, required=False, default='(10,7)', help='Default chess board grid size. default=(10,7)')
    parser.add_argument('-cam', type=int, required=False, default=0, help='WebCam #. default=0')
    parser.add_argument('-o', '--output', type=str, required=False, default='extrinsics.json', help='Extrinsics data (rotate + translation matrix) for human_pose_estimation_3d demo. default=\'extrinsics.json\'')
    args = parser.parse_args()
    main(args)
